# 基础代码模版
## 递归代码模版
### Python代码模版
```Python
    def recursion(level, param1, param2, ...): 
        # recursion terminator 
        if level > MAX_LEVEL: 
        process_result 
        return 

        # process logic in current level 
        process(level, data...) 

        # drill down 
        self.recursion(level + 1, p1, ...) 

        # reverse the current level status if needed
```
### Java代码模版
```Java
public void recur(int level, int param) { 

    // terminator 
    if (level > MAX_LEVEL) { 
        // process result 
        return; 
    } 

    // process current logic 
    process(level, param); 

    // drill down 
    recur( level: level + 1, newParam); 

    // restore current status 
    
    }
```
## 分治代码模版
```Python
    def divide_conquer(problem, param1, param2, ...): 
    # recursion terminator 
    if problem is None: 
        print_result 
        return 

    # prepare data 
    data = prepare_data(problem) 
    subproblems = split_problem(problem, data) 

    # conquer subproblems 
    subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
    subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
    subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
    …

    # process and generate the final result 
    result = process_result(subresult1, subresult2, subresult3, …)
        
    # revert the current level states
```

## Trie树
```Python
class Trie(object): 
    def __init__(self): 
        self.root = {} 
        self.end_of_word = "#"
    
    def insert(self, word): 
        node = self.root 
        for char in word: 
            node = node.setdefault(char, {}) 
        node[self.end_of_word] = self.end_of_word 
    
    def search(self, word): 
        node = self.root 
        for char in word: 
            if char not in node: 
                return False 
            node = node[char] 
        return self.end_of_word in node 

    def startsWith(self, prefix): 
        node = self.root 
        for char in prefix: 
            if char not in node: 
                return False 
            node = node[char] 
        return True
```

## DFS代码模板
### 递归写法
```Python
visited = set() 
def dfs(node, visited): 
    if node in visited: # terminator 
        # already visited 
        return 
    
    visited.add(node) 
    
    # process current node here. 
    ...
    for next_node in node.children(): 
        if not next_node in visited: 
            dfs(next_node, visited)
```

### 非递归写法
```Python
def DFS(self, tree): 
    if tree.root is None: 
        return [] 
    
    visited, stack = [], [tree.root] 

    while stack: 
        node = stack.pop() 
        visited.add(node) 
        process (node) 
        nodes = generate_related_nodes(node) 
        stack.push(nodes) 

    # other processing work 
    ...
```
## BFS代码
```Python
def BFS(graph, start, end): 
    queue = [] 
    queue.append([start]) 
    visited.add(start) 

    while queue: 
        node = queue.pop() 
        visited.add(node) 
 
        process(node) 
        nodes = generate_related_nodes(node) 
        queue.push(nodes)
```
